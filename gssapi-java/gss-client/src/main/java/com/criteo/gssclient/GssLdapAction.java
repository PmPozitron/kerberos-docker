package com.criteo.gssclient;

import com.criteo.gssutils.Utils;
import org.ietf.jgss.GSSContext;
import org.ietf.jgss.GSSManager;
import org.ietf.jgss.GSSName;
import org.ietf.jgss.MessageProp;
import org.ietf.jgss.Oid;
import org.springframework.ldap.core.LdapTemplate;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.net.Socket;
import java.security.PrivilegedExceptionAction;

public class GssLdapAction implements PrivilegedExceptionAction<Object> {

    private LdapTemplate ldapTemplate;

    public GssLdapAction() {
        this.ldapTemplate = new LdapTemplate();
    }

    public Object run() throws Exception {
        // This Oid is used to represent the Kerberos version 5 GSS-API
        // mechanism. It is defined in RFC 1964. We will use this Oid
        // whenever we need to indicate to the GSS-API that it must
        // use Kerberos for some purpose.
        Oid krb5Oid = new Oid("1.2.840.113554.1.2.2");

        GSSManager manager = GSSManager.getInstance();

        String princ = "DESKTOP-9VIJ310";
//        String princ = "bob@EXAMPLE.COM";
        // Create a GSSName out of the server's name.
        GSSName serverName = manager.createName(princ, GSSName.NT_HOSTBASED_SERVICE);

        // Create a GSSContext for mutual authentication with the
        // server.
        // - serverName is the GSSName that represents the server.
        // - krb5Oid is the Oid that represents the mechanism to
        // use. The client chooses the mechanism to use.
        // - null is passed in for client credentials
        // - DEFAULT_LIFETIME lets the mechanism decide how long the
        // context can remain valid.
        // Note: Passing in null for the credentials asks GSS-API to
        // use the default credentials. This means that the mechanism
        // will look among the credentials stored in the current Subject
        // to find the right kind of credentials that it needs.
        GSSContext context = manager.createContext(serverName, krb5Oid, null, GSSContext.DEFAULT_LIFETIME);

        // Set the desired optional features on the context. The client
        // chooses these options.

        context.requestMutualAuth(true); // Mutual authentication
        context.requestConf(true); // Will use confidentiality later
        context.requestInteg(true); // Will use integrity later

        // Do the context eastablishment loop

        byte[] token = new byte[0];

        while (!context.isEstablished()) {

            // token is ignored on the first call
            token = context.initSecContext(token, 0, token.length);

            // Send a token to the server if one was generated by
            // initSecContext
            if (token != null) {
                System.out.println(token);
//                if (verbose) {
//                    System.out.println("Will send token of size " + token.length + " from initSecContext.");
//                    System.out.println("writing token = " + Utils.getHexBytes(token));
//                }

//                outStream.writeInt(token.length);
//                outStream.write(token);
//                outStream.flush();
//            }

            // If the client is done with context establishment
            // then there will be no more tokens to read in this loop
//            if (!context.isEstablished()) {
//                token = new byte[inStream.readInt()];
//                if (verbose) {
//                    System.out.println("reading token = " + Utils.getHexBytes(token));
//                    System.out.println("Will read input token of size " + token.length
//                            + " for processing by initSecContext");
//                }
//                inStream.readFully(token);
            }

        }

        System.out.println("Context Established! ");
        System.out.println("Client principal is " + context.getSrcName());
        System.out.println("Server principal is " + context.getTargName());

        // If mutual authentication did not take place, then only the
        // client was authenticated to the server. Otherwise, both
        // client and server were authenticated to each other.
        if (context.getMutualAuthState()) {
            System.out.println("Mutual authentication took place!");
        }

        byte[] messageBytes = "Hello There!".getBytes("UTF-8");

        // The first MessageProp argument is 0 to request
        // the default Quality-of-Protection.
        // The second argument is true to request
        // privacy (encryption of the message).
        MessageProp prop = new MessageProp(0, true);

        // Encrypt the data and send it across. Integrity protection
        // is always applied, irrespective of confidentiality
        // (i.e., encryption).
        // You can use the same token (byte array) as that used when
        // establishing the context.
        System.out.println("Sending message: " + new String(messageBytes, "UTF-8"));
        token = context.wrap(messageBytes, 0, messageBytes.length, prop);
//        outStream.writeInt(token.length);
//        outStream.write(token);
//        outStream.flush();
//
//        // Now we will allow the server to decrypt the message,
//        // append a time/date on it, and send then it back.
//        token = new byte[inStream.readInt()];
//        System.out.println("Will read token of size " + token.length);
//        inStream.readFully(token);
//        byte[] replyBytes = context.unwrap(token, 0, token.length, prop);
//
//        System.out.println("Received message: " + new String(replyBytes, "UTF-8"));
//
//        System.out.println("Done.");
//        context.dispose();
//        socket.close();

        return null;
    }

}
